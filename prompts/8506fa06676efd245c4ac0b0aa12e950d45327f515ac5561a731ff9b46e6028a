---
description: Style guide for writing tutorials
category: conduct
---

# 教程写作规范

> 教程的目标：让读者**理解"为什么"**，而不只是"怎么做"。

---

## 一、结构框架

### 1.1 开篇：定位本章

每篇教程必须开门见山，告诉读者**为什么要读这篇**：

```markdown
# 主题名称

> **核心问题**：[本章要解决什么问题？一句话]

---

## 0. 前置知识（可选）

阅读本章需要了解：
- 概念 A（见 [链接]）
- 概念 B
```

**两种开篇方式**：

| 方式 | 适用场景 | 示例 |
|------|---------|------|
| **核心问题** | 独立主题 | "BeamState 和 BeamBlock 是什么关系？" |
| **承接上章** | 系列教程 | "上章讲了 R1CS，但验证效率低。本章解决这个问题。" |

### 1.2 正文：层层递进

按逻辑顺序组织，用**编号章节**：

```markdown
## 1. 问题是什么
## 2. 核心思想
## 3. 详细展开
## 4. 代码/例子验证
## 5. 总结
```

### 1.3 结尾：收束与衔接

```markdown
## N. 本章小结

| 概念 | 说明 |
|------|------|
| 概念 A | 一句话解释 |
| 概念 B | 一句话解释 |

**核心洞察**：[一句话总结本章最重要的理解]

---

下一篇：[下一章主题]
```

---

## 二、写作原则

### 2.1 先"为什么"，后"怎么做"

❌ 直接讲方法：
> "SSZ 使用小端序和偏移量表。"

✅ 先讲动机：
> **问题**：多个客户端序列化相同数据，必须得到相同字节，否则共识崩溃。
>
> **SSZ 的解法**：确定性序列化——小端序、无字段名、固定偏移量。

### 2.2 问题 → 解答 模式

遇到读者可能困惑的地方，主动提出并解答：

```markdown
### 0.1 "自指"问题：Block 里的 state_root 哪来的？

你可能会困惑：Block 是 STF 的输入，State 是输出，但 Block.state_root = hash(输出)——这不是循环吗？

**答案**：不是。Proposer 先执行 STF 算出 post_state，再把 hash 填入 block。
```

### 2.3 抽象必有具体

每个抽象概念必须配**具体例子**或**数值验证**：

```markdown
**规则**：补码 = 绝对值取反 + 1

**例子**：-5 的 12 位补码
1. 绝对值 5：0000 0000 0101
2. 取反：    1111 1111 1010
3. 加 1：    1111 1111 1011 = 0xFFB
```

### 2.4 新概念必解释

引入新术语/符号时，**立即**给出定义：

```markdown
**Cycles** 是执行阶段消耗的 RISC-V 指令数，不是证明生成的时间。

| 概念 | 说明 |
|------|------|
| 1 cycle | 约等于 1 条 RISC-V 指令 |
| Cycles 与证明的关系 | Cycles 越多 → 执行轨迹越长 → 证明生成越慢 |
```

---

## 三、表达技巧

### 3.1 善用表格

| 用途 | 示例场景 |
|------|---------|
| **对比** | R-type vs I-type 指令格式 |
| **API 速查** | `io::read()` / `io::commit()` 的作用 |
| **映射关系** | SP1 API ↔ ZK 基础概念 |
| **字段说明** | BeamState 每个字段的用途和更新时机 |

### 3.2 善用图解

**Mermaid 流程图**：展示流程、状态转换
```markdown
```mermaid
flowchart LR
    S0["State 0"] -->|"Block 1"| S1["State 1"]
    S1 -->|"Block 2"| S2["State 2"]
```
```

**Mermaid 时序图**：展示交互过程
```markdown
```mermaid
sequenceDiagram
    participant P as Prover
    participant V as Verifier
    P->>V: 承诺 com(A)
    V->>P: 随机挑战 τ
    P->>V: 打开 A(τ)
```
```

**ASCII 图**：展示数据布局、内存结构
```markdown
┌───────────┬─────┬────┬─────┬─────────┐
│ imm[11:0] │ rs1 │ f3 │ rd  │ opcode  │
│   12位    │ 5位 │ 3位│ 5位 │   7位   │
└───────────┴─────┴────┴─────┴─────────┘
```

### 3.3 代码 + 解释紧密结合

代码块后紧跟**逐行/逐段解释**：

```markdown
```rust
let (pk, vk) = client.setup(ELF);
```

| 参数 | 含义 |
|------|------|
| `pk` | Proving Parameters，生成证明所需的全部参数 |
| `vk` | Verification Parameters，验证证明所需的参数 |
```

### 3.4 分步骤讲解复杂过程

```markdown
### 第一步：选择求值点

我们有 $m$ 个约束，选择 $\{1, 2, ..., m\}$ 作为求值点。

### 第二步：把矩阵的列变成多项式

对矩阵 A 的第 j 列，用拉格朗日插值构造 $A_j(x)$...

### 第三步：引入见证向量

用 $\vec{w}$ 对列多项式加权求和...
```

---

## 四、不同类型教程的侧重

### 4.1 代码教程（API、框架使用）

重点：**流程 + API 速查 + 完整示例**

```markdown
## 项目结构
[目录树 + 表格说明每个文件的职责]

## 交互流程
[时序图展示组件间如何配合]

## 核心 API
[表格：API | 位置 | 作用]

## 动手实验
[可操作的练习建议]
```

### 4.2 概念教程（协议、架构）

重点：**问题驱动 + 逐层深入 + 澄清困惑**

```markdown
## 先解决常见困惑
[主动提出并解答读者可能的疑惑]

## 核心概念
[定义 + 为什么重要]

## 详细机制
[分步骤展开]

## 在实际系统中的角色
[与其他组件的关系]
```

### 4.3 数学/理论教程

重点：**直觉先行 + 公式必解释 + 例子验证**

```markdown
## 前置知识
[必要的数学定理，附直觉解释]

## 问题回顾
[上章遗留的问题，本章的目标]

## 核心思想
[先给直觉，一两句话概括方法]

## 详细推导
[公式 + 紧跟通俗解释 + 数值例子]

## 与证明系统的关联
[如何嵌入更大的图景]
```

---

## 五、禁止事项

| 禁止 | 原因 | 正确做法 |
|------|------|---------|
| 对话式口吻 | "我来给你讲讲..." 不适合文档 | 直接陈述 |
| 无解释的公式 | 读者看不懂 | 公式后紧跟通俗理解 |
| 孤立的概念 | 不知道为什么需要它 | 先讲问题，再引入概念 |
| TODO/待补充 | 半成品 | 写完再提交 |
| 堆砌信息 | 没有逻辑主线 | 围绕核心问题组织 |

---

## 六、检查清单

写完后逐项检查：

- [ ] 开篇有"核心问题"或"承接上章"？
- [ ] 每个新概念都有解释？
- [ ] 抽象概念有具体例子？
- [ ] 公式有通俗理解？
- [ ] 复杂流程有图解？
- [ ] 结尾有表格总结？
- [ ] 有"核心洞察"一句话？
- [ ] 有章节衔接（下一篇）？
